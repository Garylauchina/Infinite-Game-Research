<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Infinite Game — IGM Structure Visualization</title>
  <style>
    * { box-sizing: border-box; }
    html, body { margin:0; padding:0; width:100%; height:100%; background:#0a0a0f; overflow:hidden; font-family: ui-monospace, monospace; color:#fff; }
    #container { display:flex; width:100%; height:100%; }
    #canvas-container { flex:1; position:relative; background:#050510; }
    canvas { display:block; width:100%; height:100%; }
    #controls { width:280px; background:rgba(10,10,20,0.95); padding:16px; overflow-y:auto; border-left:1px solid rgba(255,255,255,0.1); }
    .control-group { margin-bottom:16px; }
    .control-group label { display:block; font-size:11px; margin-bottom:4px; opacity:0.7; text-transform:uppercase; letter-spacing:0.5px; }
    .control-group input, .control-group select, .control-group button { width:100%; padding:8px; font-size:12px; background:#1a1a2e; border:1px solid #333; color:#fff; border-radius:4px; }
    button { cursor:pointer; transition:background 0.2s; }
    button:hover { background:#2a2a3e; }
    button.active { background:#3a5; }
    #scrubber { width:100%; margin:8px 0; }
    #status { font-size:10px; opacity:0.6; margin-top:12px; line-height:1.6; }
    .metric { font-size:11px; opacity:0.8; margin:4px 0; }
  </style>
</head>
<body>
  <div id="container">
    <div id="canvas-container">
      <canvas id="cv"></canvas>
    </div>
    <div id="controls">
      <div class="control-group">
        <button id="play-pause">Play</button>
      </div>
      <div class="control-group">
        <label>Speed</label>
        <select id="speed-select">
          <option value="1">1x</option>
          <option value="2">2x</option>
          <option value="4">4x</option>
          <option value="16">16x</option>
        </select>
      </div>
      <div class="control-group">
        <label>Time: <span id="time-display">0</span> / <span id="max-time">0</span></label>
        <input type="range" id="scrubber" min="0" max="0" value="0" step="1">
      </div>
      <div class="control-group">
        <button id="reset-btn">Reset to t=0</button>
      </div>
      <div id="status">
        <div class="metric">Window: <span id="window-ticks">2000</span> ticks</div>
        <div class="metric">Agents: <span id="agent-count">0</span></div>
        <div class="metric">Matches: <span id="match-count">0</span></div>
        <div class="metric">t: <span id="current-t">0</span></div>
      </div>
    </div>
  </div>

<script>
(() => {
  const cv = document.getElementById('cv');
  const ctx = cv.getContext('2d', { alpha: false });
  const playPauseBtn = document.getElementById('play-pause');
  const speedSelect = document.getElementById('speed-select');
  const scrubber = document.getElementById('scrubber');
  const timeDisplay = document.getElementById('time-display');
  const maxTimeDisplay = document.getElementById('max-time');
  const resetBtn = document.getElementById('reset-btn');

  let canvasW = 0, canvasH = 0, DPR = 1;
  function resize() {
    DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvasW = Math.floor(cv.parentElement.clientWidth * DPR);
    canvasH = Math.floor(cv.parentElement.clientHeight * DPR);
    cv.width = canvasW; cv.height = canvasH;
    cv.style.width = cv.parentElement.clientWidth + 'px';
    cv.style.height = cv.parentElement.clientHeight + 'px';
  }
  addEventListener('resize', resize);
  resize();

  // =========================
  // 配置
  // =========================
  const API_BASE = window.location.origin;
  const W_TICKS = 2000;  // 窗口大小
  const R_TICKS = 50;     // 重新计算坐标的间隔
  const BASE_STEP = 10;   // 基础每帧步进

  // =========================
  // 数据
  // =========================
  let manifest = [];
  let tickData = [];  // 所有 tick 数据
  let replayIdx = 0;
  let playing = false;
  let speed = 1.0;
  let maxTick = 0;
  let currentSegmentIndex = -1;
  let isLoadingSegment = false;

  // IGM 图结构
  let graph = {
    nodes: new Map(),  // id -> {id, experience, degree, x, y}
    edges: new Map(),  // "i,j" -> weight
    adjacencyMatrix: null,
    coords: null  // [x, y] 坐标数组
  };

  let lastCoordUpdate = -1;  // 上次更新坐标的 tick

  // =========================
  // 数据加载
  // =========================
  async function loadManifest() {
    const res = await fetch(`${API_BASE}/segments`);
    if (!res.ok) throw new Error(`HTTP ${res.status}`);
    return await res.json();
  }

  async function loadSegmentStream(segPath) {
    const url = `${API_BASE}/segment/${segPath}?format=jsonl`;
    console.log(`[Load] Fetching: ${url}`);
    const res = await fetch(url);
    if (!res.ok) {
      console.error(`[Load] HTTP ${res.status}: ${res.statusText}`);
      throw new Error(`HTTP ${res.status}`);
    }
    
    console.log(`[Load] Response received, starting stream...`);
    const reader = res.body.getReader();
    const decoder = new TextDecoder();
    const ticks = [];
    let buffer = '';
    let lineCount = 0;
    
    while (true) {
      const { done, value } = await reader.read();
      if (done) {
        if (buffer.trim()) {
          try {
            const obj = JSON.parse(buffer.trim());
            if (obj.type === 'tick') {
              ticks.push(obj);
              lineCount++;
            }
          } catch(e) {
            console.warn('[Load] Parse error on final buffer:', e);
          }
        }
        break;
      }
      
      buffer += decoder.decode(value, { stream: true });
      const lines = buffer.split('\n');
      buffer = lines.pop() || '';
      
      for (const line of lines) {
        if (line.trim()) {
          try {
            const obj = JSON.parse(line);
            if (obj.type === 'tick') {
              ticks.push(obj);
              lineCount++;
              if (lineCount % 10000 === 0) {
                console.log(`[Load] Parsed ${lineCount} ticks...`);
              }
            }
          } catch(e) {
            console.warn('[Load] Parse error:', line.substring(0, 100), e);
          }
        }
      }
    }
    
    console.log(`[Load] Stream complete. Total ticks: ${ticks.length}`);
    return ticks;
  }

  async function loadFromZero() {
    try {
      manifest = await loadManifest();
      
      if (manifest.length === 0) {
        console.log('[Load] No segments available yet. Waiting for first segment to complete...');
        // 显示等待提示
        document.getElementById('current-t').textContent = 'Waiting...';
        document.getElementById('agent-count').textContent = '0';
        document.getElementById('match-count').textContent = '0';
        // 5秒后重试
        setTimeout(loadFromZero, 5000);
        return;
      }
      
      manifest.sort((a, b) => a.start_t - b.start_t);
      maxTick = manifest[manifest.length - 1].end_t;
      maxTimeDisplay.textContent = maxTick;
      scrubber.max = maxTick;
      
      // 加载第一个段
      const firstSeg = manifest[0];
      console.log(`[Load] Loading segment: ${firstSeg.path}`);
      console.log(`[Load] Segment range: t=${firstSeg.start_t}..${firstSeg.end_t}`);
      
      const ticks = await loadSegmentStream(firstSeg.path);
      console.log(`[Load] Received ${ticks.length} ticks from stream`);
      
      tickData = ticks;
      currentSegmentIndex = 0;
      replayIdx = 0;
      lastCoordUpdate = -1;
      
      // 更新 maxTick（基于所有段）
      maxTick = manifest[manifest.length - 1].end_t;
      maxTimeDisplay.textContent = maxTick;
      scrubber.max = maxTick;
      
      console.log(`[Load] Loaded ${ticks.length} ticks from first segment`);
      console.log(`[Load] Total segments available: ${manifest.length}, max tick: ${maxTick}`);
      if (ticks.length > 0) {
        console.log(`[Load] First tick:`, ticks[0]);
        console.log(`[Load] Last tick:`, ticks[ticks.length - 1]);
        console.log(`[Load] Sample tick agents:`, ticks[0]?.agents?.length || 0);
        console.log(`[Load] Sample tick matches:`, ticks[0]?.matches?.length || 0);
      } else {
        console.warn(`[Load] No ticks loaded!`);
      }
    } catch(e) {
      console.error('[Load] Failed:', e);
    }
  }

  async function loadNextSegment() {
    if (isLoadingSegment) return;
    if (currentSegmentIndex >= manifest.length - 1) return;
    
    isLoadingSegment = true;
    const nextIndex = currentSegmentIndex + 1;
    const nextSeg = manifest[nextIndex];
    
    try {
      const ticks = await loadSegmentStream(nextSeg.path);
      tickData.push(...ticks);
      currentSegmentIndex = nextIndex;
      console.log(`[Load] Loaded segment ${currentSegmentIndex + 1}/${manifest.length}: ${ticks.length} ticks`);
    } catch(e) {
      console.error('[Load] Failed to load next segment:', e);
    } finally {
      isLoadingSegment = false;
    }
  }

  // =========================
  // IGM 图构建
  // =========================
  function buildGraph(windowStart, windowEnd) {
    console.log(`[BuildGraph] Starting for window [${windowStart}, ${windowEnd}], tickData.length=${tickData.length}`);
    const startTime = performance.now();
    
    // 重置图
    graph.nodes.clear();
    graph.edges.clear();
    
    if (tickData.length === 0) {
      console.warn(`[BuildGraph] No tick data available`);
      return;
    }
    
    // 收集窗口内的数据（优化：使用二分查找）
    let startIdx = 0;
    let endIdx = tickData.length - 1;
    
    // 二分查找起始位置
    for (let i = 0; i < tickData.length; i++) {
      if (tickData[i] && tickData[i].t >= windowStart) {
        startIdx = i;
        break;
      }
    }
    
    // 二分查找结束位置
    for (let i = tickData.length - 1; i >= 0; i--) {
      if (tickData[i] && tickData[i].t <= windowEnd) {
        endIdx = i;
        break;
      }
    }
    
    const windowTicks = tickData.slice(startIdx, endIdx + 1).filter(t => t && t.t >= windowStart && t.t <= windowEnd);
    console.log(`[BuildGraph] Window ticks: ${windowTicks.length} (indices ${startIdx}..${endIdx}, filtered from ${endIdx - startIdx + 1})`);
    
    // 构建节点和边
    let tickCount = 0;
    for (const tick of windowTicks) {
      tickCount++;
      if (tickCount % 1000 === 0) {
        console.log(`[BuildGraph] Processing tick ${tickCount}/${windowTicks.length}...`);
      }
      
      // 更新节点（agents）
      for (const agent of tick.agents || []) {
        if (!graph.nodes.has(agent.id)) {
          graph.nodes.set(agent.id, {
            id: agent.id,
            experience: agent.experience || 0,
            degree: 0,
            x: 0, y: 0
          });
        }
        const node = graph.nodes.get(agent.id);
        node.experience = agent.experience || 0;  // 更新最新 experience
      }
      
      // 构建边（matches）
      // 注意：当前 matches 只有 action 索引，我们需要推断配对关系
      // 简化：将所有成交的 action 视为相互连接的节点
      const matchIndices = (tick.matches || []).map(m => m.a).filter(a => a >= 0 && a < (tick.agents || []).length);
      
      // 优化：限制边的数量，避免 O(n²) 爆炸
      if (matchIndices.length > 0 && matchIndices.length <= 50) {
        for (let i = 0; i < matchIndices.length; i++) {
          for (let j = i + 1; j < matchIndices.length; j++) {
            const a = matchIndices[i];
            const b = matchIndices[j];
            // 找到对应的 agent id（通过 action id）
            const agentA = tick.agents?.[a]?.id;
            const agentB = tick.agents?.[b]?.id;
            if (agentA !== undefined && agentB !== undefined && agentA !== agentB) {
              const key = `${Math.min(agentA, agentB)},${Math.max(agentA, agentB)}`;
              graph.edges.set(key, (graph.edges.get(key) || 0) + 1);
            }
          }
        }
      }
    }
    
    // 计算节点度
    for (const [key, weight] of graph.edges) {
      const [a, b] = key.split(',').map(Number);
      if (graph.nodes.has(a)) graph.nodes.get(a).degree += weight;
      if (graph.nodes.has(b)) graph.nodes.get(b).degree += weight;
    }
    
    const elapsed = performance.now() - startTime;
    console.log(`[BuildGraph] Complete: ${graph.nodes.size} nodes, ${graph.edges.size} edges (${elapsed.toFixed(1)}ms)`);
  }

  // =========================
  // Spectral Embedding（简化版）
  // =========================
  function computeSpectralEmbedding() {
    const nodes = Array.from(graph.nodes.values());
    const n = nodes.length;
    
    if (n === 0) {
      graph.coords = [];
      return;
    }
    
    if (n === 1) {
      graph.coords = [[0, 0]];
      nodes[0].x = 0;
      nodes[0].y = 0;
      return;
    }
    
    // 构建邻接矩阵
    const A = new Array(n).fill(0).map(() => new Array(n).fill(0));
    const nodeIds = nodes.map(n => n.id);
    const idToIndex = new Map();
    nodeIds.forEach((id, idx) => idToIndex.set(id, idx));
    
    for (const [key, weight] of graph.edges) {
      const [a, b] = key.split(',').map(Number);
      const i = idToIndex.get(a);
      const j = idToIndex.get(b);
      if (i !== undefined && j !== undefined) {
        A[i][j] = weight;
        A[j][i] = weight;
      }
    }
    
    // 构建度矩阵和拉普拉斯矩阵
    const D = new Array(n).fill(0).map(() => new Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      let degree = 0;
      for (let j = 0; j < n; j++) {
        degree += A[i][j];
      }
      D[i][i] = degree || 1;  // 避免除零
    }
    
    // L = D - A（未归一化拉普拉斯）
    const L = new Array(n).fill(0).map(() => new Array(n).fill(0));
    for (let i = 0; i < n; i++) {
      for (let j = 0; j < n; j++) {
        L[i][j] = D[i][j] - A[i][j];
      }
    }
    
    // 简化：使用幂迭代法近似特征向量（或使用库）
    // 这里使用简单的随机初始化 + 迭代
    let v2 = new Array(n).fill(0).map(() => Math.random() - 0.5);
    let v3 = new Array(n).fill(0).map(() => Math.random() - 0.5);
    
    // 正交化
    const dot = (a, b) => a.reduce((sum, x, i) => sum + x * b[i], 0);
    const norm = (a) => Math.sqrt(a.reduce((sum, x) => sum + x * x, 0));
    
    // 简单迭代（近似第二、第三特征向量）
    for (let iter = 0; iter < 50; iter++) {
      // 矩阵向量乘法
      const Lv2 = new Array(n).fill(0);
      const Lv3 = new Array(n).fill(0);
      for (let i = 0; i < n; i++) {
        for (let j = 0; j < n; j++) {
          Lv2[i] += L[i][j] * v2[j];
          Lv3[i] += L[i][j] * v3[j];
        }
      }
      
      // 归一化
      const n2 = norm(Lv2);
      const n3 = norm(Lv3);
      if (n2 > 0) v2 = Lv2.map(x => x / n2);
      if (n3 > 0) v3 = Lv3.map(x => x / n3);
      
      // 正交化 v3 相对于 v2
      const proj = dot(v3, v2);
      v3 = v3.map((x, i) => x - proj * v2[i]);
      const n3_ortho = norm(v3);
      if (n3_ortho > 0) v3 = v3.map(x => x / n3_ortho);
    }
    
    // 更新节点坐标
    graph.coords = [];
    for (let i = 0; i < n; i++) {
      const x = v2[i] * 100;  // 缩放
      const y = v3[i] * 100;
      nodes[i].x = x;
      nodes[i].y = y;
      graph.coords.push([x, y]);
    }
  }

  // =========================
  // 渲染
  // =========================
  function render() {
    // 清屏
    ctx.fillStyle = '#0a0a0f';
    ctx.fillRect(0, 0, canvasW, canvasH);
    
    if (tickData.length === 0) {
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = (16*DPR) + 'px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('No data. Click "Reset to t=0" to load.', canvasW/2, canvasH/2);
      requestAnimationFrame(render);
      return;
    }
    
    if (replayIdx >= tickData.length) {
      replayIdx = tickData.length - 1;  // 保持在最后一个有效索引
    }
    
    const currentTick = tickData[replayIdx];
    if (!currentTick) {
      console.warn(`[Render] Invalid tick at index ${replayIdx}/${tickData.length}`);
      requestAnimationFrame(render);
      return;
    }
    
    const currentT = currentTick.t;
    
    // 构建窗口（确保有足够的数据）
    const windowStart = Math.max(0, currentT - W_TICKS);
    const windowEnd = currentT;
    
    // 检查窗口内是否有数据
    const windowTicks = tickData.filter(t => t && t.t >= windowStart && t.t <= windowEnd);
    if (windowTicks.length === 0) {
      console.warn(`[Render] No ticks in window [${windowStart}, ${windowEnd}]`);
      requestAnimationFrame(render);
      return;
    }
    
    // 每 R_TICKS 重新计算坐标（但首次必须计算）
    // 或者如果窗口大小变化超过阈值，也要重新计算
    const windowSize = windowEnd - windowStart;
    const shouldUpdate = (currentT - lastCoordUpdate >= R_TICKS || lastCoordUpdate < 0) && windowSize > 0;
    
    if (shouldUpdate) {
      console.log(`[Render] Building graph for window [${windowStart}, ${windowEnd}], currentT=${currentT}, replayIdx=${replayIdx}, windowSize=${windowSize}`);
      try {
        buildGraph(windowStart, windowEnd);
        console.log(`[Render] Graph built: ${graph.nodes.size} nodes, ${graph.edges.size} edges`);
        if (graph.nodes.size > 0) {
          console.log(`[Render] Computing spectral embedding for ${graph.nodes.size} nodes...`);
          computeSpectralEmbedding();
          console.log(`[Render] Coordinates computed for ${graph.nodes.size} nodes`);
        } else {
          console.warn(`[Render] Graph is empty! Window ticks: ${windowTicks.length}, windowSize=${windowSize}`);
        }
        lastCoordUpdate = currentT;
      } catch(e) {
        console.error(`[Render] Error building graph:`, e);
        console.error(e.stack);
      }
    }
    
    // 渲染图
    const centerX = canvasW / 2;
    const centerY = canvasH / 2;
    const scale = Math.min(canvasW, canvasH) * 0.4;  // 缩放因子
    
    // 绘制边
    if (graph.edges.size > 0) {
      ctx.strokeStyle = 'rgba(100, 150, 255, 0.3)';
      for (const [key, weight] of graph.edges) {
        const [a, b] = key.split(',').map(Number);
        const nodeA = graph.nodes.get(a);
        const nodeB = graph.nodes.get(b);
        if (nodeA && nodeB && nodeA.x !== undefined && nodeB.x !== undefined) {
          const x1 = centerX + nodeA.x * scale / 100;
          const y1 = centerY + nodeA.y * scale / 100;
          const x2 = centerX + nodeB.x * scale / 100;
          const y2 = centerY + nodeB.y * scale / 100;
          
          ctx.lineWidth = Math.min(3 * DPR, weight * 0.5 * DPR);
          ctx.beginPath();
          ctx.moveTo(x1, y1);
          ctx.lineTo(x2, y2);
          ctx.stroke();
        }
      }
    }
    
    // 绘制节点
    if (graph.nodes.size > 0) {
      for (const node of graph.nodes.values()) {
        if (node.x === undefined || node.y === undefined) continue;
        
        const x = centerX + node.x * scale / 100;
        const y = centerY + node.y * scale / 100;
        
        // 节点大小 = degree（至少 3px）
        const radius = Math.max(3 * DPR, Math.min(15 * DPR, (node.degree || 1) * 0.5 * DPR));
        
        // 节点颜色 = experience（低->暗，高->亮）
        const expNorm = Math.max(0, Math.min(1, (node.experience + 2) / 4));  // 归一化到 [0,1]
        const intensity = Math.floor(expNorm * 255);
        ctx.fillStyle = `rgb(${intensity}, ${intensity + 50}, ${intensity + 100})`;
        
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, Math.PI * 2);
        ctx.fill();
        
        // 外圈
        ctx.strokeStyle = `rgba(${intensity}, ${intensity + 50}, ${intensity + 100}, 0.5)`;
        ctx.lineWidth = 1 * DPR;
        ctx.stroke();
      }
    } else {
      // 如果没有节点，显示提示
      ctx.fillStyle = 'rgba(255,255,255,0.5)';
      ctx.font = (14*DPR) + 'px monospace';
      ctx.textAlign = 'center';
      ctx.fillText('Building graph...', canvasW/2, canvasH/2);
    }
    
    // 更新状态
    document.getElementById('current-t').textContent = currentT;
    document.getElementById('agent-count').textContent = graph.nodes.size;
    const matchCount = Array.from(graph.edges.values()).reduce((a, b) => a + b, 0);
    document.getElementById('match-count').textContent = matchCount;
    
    requestAnimationFrame(render);
  }

  // =========================
  // 回放引擎
  // =========================
  async function replayTick() {
    if (!playing) {
      // 即使暂停，也要继续调用（保持循环），但不推进 replayIdx
      requestAnimationFrame(replayTick);
      return;
    }
    
    // 如果到达当前数据的末尾，尝试加载下一段
    if (replayIdx >= tickData.length) {
      if (currentSegmentIndex < manifest.length - 1 && !isLoadingSegment) {
        console.log(`[Replay] Reached end of current data (${tickData.length} ticks), loading next segment...`);
        try {
          await loadNextSegment();
          // 如果成功加载了新数据，继续播放
          if (replayIdx < tickData.length) {
            updateUI();
            requestAnimationFrame(replayTick);
            return;
          }
        } catch(e) {
          console.error(`[Replay] Failed to load next segment:`, e);
        }
      }
      
      // 如果所有段都加载完了，或者加载失败，停止播放
      playing = false;
      playPauseBtn.textContent = 'Play';
      playPauseBtn.classList.remove('active');
      console.log(`[Replay] Reached end of all data (${tickData.length} ticks, ${currentSegmentIndex + 1}/${manifest.length} segments)`);
      return;
    }
    
    const step = Math.floor(BASE_STEP * speed);
    const oldReplayIdx = replayIdx;
    const endIdx = Math.min(replayIdx + step, tickData.length - 1);
    replayIdx = endIdx + 1;
    
    // 调试：每 100 步或前 10 步输出一次进度
    if (replayIdx % 100 === 0 || replayIdx <= 10) {
      const currentTick = tickData[Math.min(replayIdx - 1, tickData.length - 1)];
      console.log(`[Replay] Progress: replayIdx=${replayIdx}/${tickData.length}, currentT=${currentTick?.t || 'N/A'}, step=${step}`);
    }
    
    // 如果 replayIdx 没有变化，说明可能有问题
    if (replayIdx === oldReplayIdx && replayIdx < tickData.length) {
      console.warn(`[Replay] replayIdx not advancing! replayIdx=${replayIdx}, step=${step}, speed=${speed}`);
    }
    
    // 预取下一段（提前 1000 点）
    if (replayIdx >= tickData.length - 1000 && currentSegmentIndex < manifest.length - 1 && !isLoadingSegment) {
      console.log(`[Replay] Prefetching next segment (current: ${currentSegmentIndex + 1}/${manifest.length}, replayIdx: ${replayIdx}/${tickData.length})`);
      loadNextSegment();  // 不 await，异步加载
    }
    
    updateUI();
    requestAnimationFrame(replayTick);
  }

  function updateUI() {
    if (tickData.length > 0 && replayIdx >= 0 && replayIdx < tickData.length) {
      const t = tickData[replayIdx].t;
      timeDisplay.textContent = t;
      scrubber.value = t;
    }
  }

  // =========================
  // 事件处理
  // =========================
  playPauseBtn.addEventListener('click', () => {
    playing = !playing;
    playPauseBtn.textContent = playing ? 'Pause' : 'Play';
    playPauseBtn.classList.toggle('active', playing);
    if (playing) {
      console.log(`[Replay] Started: replayIdx=${replayIdx}/${tickData.length}`);
      replayTick();
    } else {
      console.log(`[Replay] Paused: replayIdx=${replayIdx}/${tickData.length}`);
    }
  });

  speedSelect.addEventListener('change', (e) => {
    speed = parseFloat(e.target.value);
  });

  scrubber.addEventListener('input', async (e) => {
    const t = parseInt(e.target.value);
    
    // 二分查找
    let left = 0, right = tickData.length - 1;
    while (left <= right) {
      const mid = Math.floor((left + right) / 2);
      if (tickData[mid].t < t) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
    
    replayIdx = Math.min(Math.max(0, left), tickData.length - 1);
    updateUI();
  });

  resetBtn.addEventListener('click', async () => {
    playing = false;
    playPauseBtn.textContent = 'Play';
    playPauseBtn.classList.remove('active');
    replayIdx = 0;
    graph.nodes.clear();
    graph.edges.clear();
    lastCoordUpdate = -1;
    await loadFromZero();
  });

  // =========================
  // 启动
  // =========================
  render();
  loadFromZero();
})();
</script>
</body>
</html>
